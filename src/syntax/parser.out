Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOLEAN
    DECREMENT
    DIVIDE
    ELIF
    ELSE
    EQUAL
    FALSE
    FOR
    FUNCTION
    GREATER
    GREATER_EQUAL
    IF
    IMPORT
    IN
    INCREMENT
    INPUT
    IN_PIPE
    LCURLY
    LESS
    LESS_EQUAL
    LPAREN
    LSQUARE
    MINUS
    MODULUS
    MULTIPLY
    NOT_EQUAL
    NUMBER
    OBJECT
    OPERATOR
    OUT
    OUT_PIPE
    PLUS
    PRINT
    RCURLY
    RETURN
    RETURNS
    RPAREN
    RSQUARE
    SEPARATOR
    STRING
    STRING_LITERAL
    THIS
    TRUE
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> nextLine SEMICOLON
Rule 2     program -> <empty>
Rule 3     nextLine -> NUMBER_LITERAL
Rule 4     nextLine -> ID
Rule 5     nextLine -> SET

Terminals, with rules where they appear

BOOLEAN              : 
DECREMENT            : 
DIVIDE               : 
ELIF                 : 
ELSE                 : 
EQUAL                : 
FALSE                : 
FOR                  : 
FUNCTION             : 
GREATER              : 
GREATER_EQUAL        : 
ID                   : 4
IF                   : 
IMPORT               : 
IN                   : 
INCREMENT            : 
INPUT                : 
IN_PIPE              : 
LCURLY               : 
LESS                 : 
LESS_EQUAL           : 
LPAREN               : 
LSQUARE              : 
MINUS                : 
MODULUS              : 
MULTIPLY             : 
NOT_EQUAL            : 
NUMBER               : 
NUMBER_LITERAL       : 3
OBJECT               : 
OPERATOR             : 
OUT                  : 
OUT_PIPE             : 
PLUS                 : 
PRINT                : 
RCURLY               : 
RETURN               : 
RETURNS              : 
RPAREN               : 
RSQUARE              : 
SEMICOLON            : 1
SEPARATOR            : 
SET                  : 5
STRING               : 
STRING_LITERAL       : 
THIS                 : 
TRUE                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

nextLine             : 1
program              : 0

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . nextLine SEMICOLON
    (2) program -> .
    (3) nextLine -> . NUMBER_LITERAL
    (4) nextLine -> . ID
    (5) nextLine -> . SET

    $end            reduce using rule 2 (program -> .)
    NUMBER_LITERAL  shift and go to state 3
    ID              shift and go to state 4
    SET             shift and go to state 5

    program                        shift and go to state 1
    nextLine                       shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> nextLine . SEMICOLON

    SEMICOLON       shift and go to state 6


state 3

    (3) nextLine -> NUMBER_LITERAL .

    SEMICOLON       reduce using rule 3 (nextLine -> NUMBER_LITERAL .)


state 4

    (4) nextLine -> ID .

    SEMICOLON       reduce using rule 4 (nextLine -> ID .)


state 5

    (5) nextLine -> SET .

    SEMICOLON       reduce using rule 5 (nextLine -> SET .)


state 6

    (1) program -> nextLine SEMICOLON .

    $end            reduce using rule 1 (program -> nextLine SEMICOLON .)

